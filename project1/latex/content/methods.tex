%----------------Versuchs- und Projektaufbau--------------------------------------------------------------------------------------------------------------------------------------------------------
\subsection{Versuchs- und Projektaufbau}
\subsubsection{Ziele}
Die Herangehensweise wurde durch die Aufgabenstellung~\cite{tamselKombinatorischeLogikProjekt2025} bereits ziemlich genau definiert. Als erstes mussten die 
Vorbereitungsaufgaben~\cite[p.~3]{tamselKombinatorischeLogikProjekt2025} gelöst werden, welche grundsätzlich aus drei Teilen bestehen:
\begin{itemize}
    \item Funktionen für den \gls{bcd}-zu-7-Segment-Decoder ermitteln
    \item Konzept für den Algorithmus zur Umwandlung einer 8 Bit-Binärzahl in 3 \gls{bcd}-Ziffern
    \item \gls{le} kennelernen und über die Möglichkeiten dieser Software informieren.
\end{itemize}
Diese Aufgabenstellungen wurden vor der Projektdurchführung abgearbeitet und bereits zur Bewertung abgegeben. Sie bilden zusammen die Grundlage für dieses Projekt.

Während des Versuchs vor Ort sollen die anderen Aufgaben gemäss der Aufgabenstellung~\cite{tamselKombinatorischeLogikProjekt2025} bearbeitet werden. Diese Aufgaben sind
der Aufgabenstellung zu entnehmen und lassen sich in 5 Teilaufgaben unterteilen.
\begin{itemize}
    \item \gls{bcd}-zu-7-Segment Decoder
    \item Ripple-Carry-Addierer
    \item Borrow-Bit-Subtrahierer
    \item Ergebnisumschalter
    \item Binär-zu-\gls{bcd} Umwandler
\end{itemize}
Für das Abarbeiten dieser Aufgaben ist das Labor da, falls die Zeit nicht reicht muss noch nachgearbeitet werden. Anschliessend soll ein Projektbericht erstellt werden.

\subsubsection{Vorgehen}
Das allgemeine Vorgehen ist für alle Aufgabenstellungen gleich. Als erstes wird für jede Baugruppe eine Wahrheitstabelle erstellt. Mit dieser Wahrheitstabelle
lässt sich das \gls{kv}-Diagramm ableiten. Mit dem erstellten \gls{kv}-Diagramm lässt sich die Normalform ablesen. Falls in der Aufgabenstellung gefordert, müssen
die Normalformen erweitert werden, so dass sie auf den beschränkten Gattervorrat passen. Die daraus resultierenden Logikfunktionen werden anschliessend in Logisim-evolution (\gls{le})
implementiert. Für dieses Projekt gab es bereits eine Vorlage die verwendet werden musste. Mithilfe der Simulation in \gls{le} kann die jeweilige Funktion direkt 
auf ihre richtige Funktionsweise überprüft werden. Zum Abschluss erfolgt die Verifikation mit dem \gls{fpga}-Board der BFH, dem Leguanboard (\gls{lb}). 
Dank der \gls{le}-Vorlage werden die erstellten Funktionen bereits automatisch in die jeweilige Testumgebung integriert. Es bedarf nur noch dem Download der \gls{le}-Datei und dem
festlegen der I/O-Elemente auf dem \gls{lb}. Anschliessend kann die Logikfunktion der jeweiligen Baugruppen mit physischen Elementen getestet werden.
Für alle Baugruppen wird ein Testprotokoll erstellt und ausgefüllt. Mehr dazu in Kapitel~\ref{sec:results}.

Die oben genannten Arbeitsschritte werden im Nachhinein dokumentiert. Die Ergebnisse werden in Kapitel~\ref{sec:results} dokumentiert.

\subsection{Projektorganisation}
Das Projekt wurde ressourcentechnisch wie folgt aufgeteilt:

\paragraph{Vorbereitungsaufgaben}
\begin{itemize}
    \item Funktionen für den \gls{bcd}-zu-7-Segment-Decoder ermitteln --> Simon Eisele
    \item Konzept für den Algorithmus zur Umwandlung einer 8 Bit-Binärzahl in 3 \gls{bcd}-Ziffern --> Janis Aebischer
    \item \gls{le} kennelernen und über die Möglichkeiten dieser Software informieren. --> Janis Aebischer, Simon Eisele
\end{itemize}

\paragraph{Aufgaben}
\begin{itemize}
    \item \gls{bcd}-zu-7-Segment Decoder --> Simon Eisele
    \item Ripple-Carry-Addierer --> Simon Eisele
    \item Borrow-Bit-Subtrahierer --> Simon Eisele
    \item Ergebnisumschalter --> Janis Aebischer
    \item Binär-zu-\gls{bcd} Umwandler --> Janis Aebischer
\end{itemize}

\paragraph{Sonstiges}
\begin{itemize}
    \item Dokumentation --> Janis Aebischer, Simon Eisele
    \item Erstellen \gls{kv}-Diagramme --> Janis Aebischer
    \item Aufsetzen von \gls{latex} --> Simon Eisele
    \item Erstellen Testprotokolle --> Janis Aebischer, Simon Eisele
\end{itemize}

%----------------Versuchs- und Projektaufbau--------------------------------------------------------------------------------------------------------------------------------------------------------
\subsection{Verwendete Materialien, Werkzeuge und Software}
\paragraph{Entwerfen und Testen der Schaltungen}
Für den Entwurf der verschiedenen Schaltungen wurde die Software Logisim-evolution (\gls{le})~\cite{burchLogisimevolution2024} verwendet. Mit dieser lassen sich die Schaltungen aus Grundgattern aufbauen, sowie auch simulieren.
Für die praktischen Tests wurde das Leguan-Board (\gls{lb})~\cite{HomeLeguanDevelopers} der \gls{bfh} verwendet.

\paragraph{Projektbericht}
Der Projektbericht wurde mithilfe von \gls{latex} verfasst. Um bereits eine passende Grundlage zu haben, wurde eine Vorlage der \gls{bfh} verwendet und entsprechend unserer Bedürfnisse
angepasst.~\cite{IntroductionLaTeXManual}

%----------------Test- und Verifikationsverfahren---------------------------------------------------------------------------------------------------------------------------------------------------
\subsection{Test- und Verifikationsverfahren}
Jede entwickelte Schaltung wird in der Simulation und auf der Hardware überprüft. Die Simulation erfolgt in \gls{le}. Auf dem \gls{lb} erfolgt die Verifikation der Funktion manuell
durch betätigen der DIP-Schalter und visuell über die 7-Segement-Anzeigen. Als Anzeige für \textit{overflow} oder \textit{underflow} werden die verbauten LED's auf dem \gls{lb} verwendet.
Für den Test grösserer Schaltungen eignen sich vorwiegend Werte, mit welchen die Sonderfälle abgedeckt werden können. Diese sind Überlauf, Unterlauf und Grenzwerte der \gls{bcd}-Darstellung. Die Ergebnisse sind in Kapitel \ref{sec:results} ersichtlich.
Alle Tests wurden zuerst in Excel festgehalten und anschliessend in \gls{latex} übernommen.

%----------------Spezifische Methoden pro Baugruppe-------------------------------------------------------------------------------------------------------------------------------------------------
\subsection{Spezifische Methoden pro Baugruppe}
Spezifische Methodik für bestimmte Baugruppen, falls etwas nicht dem Standardschema folgt.

\subsubsection{BCD-zu-7-Segment Decoder}

\paragraph{7-Segment-Anzeige}
Die 7-Segment-Anzeige besteht aus sieben einzeln ansteuerbaren Leuchtsegmenten, welche in Form einer Acht angeordnet sind. Durch unterschiedliche Ansteuerung dieser acht Segmente
lassen sich die Ziffern 0 bis 9 darstellen. Die Segmente werden mit den Buchstaben A bis G bezeichnet. Zusätzlich gibt es noch ein 9. Segment, mit welchem sich ein Punkt nach der Ziffer
darstellen lässt. Dieses wird aber im folgenden ignoriert, da es für die Aufgaben nicht benötigt wird und irrelevant ist.
\begin{figure}[H]
    \centering
    \includegraphics[width=0.25\textwidth]{bcd_to_7segment/7-segement-display.png}
    \caption{Anordnung der Segmente einer 7-Segment-Anzeige~\cite[Abb.~1]{tamselKombinatorischeLogikProjekt2025}}
    \label{fig:7-segemnt-display}
\end{figure}

\paragraph{Wahrheitstabelle}
\noindent Aus den Abbildungen~\ref{fig:7-segemnt-display} und~\ref{fig:numbers_on_a_7-segment-display} ist ersichtlich, welche Segmente A bis G zur Darstellung der einzelnen Ziffern aktiviert werden müssen.
Zur Ansteuerung der 7-Segment-Anzeige werden vier Bits (ein Nibble) verwendet, womit die Dezimalzahlen 0 bis 15 codierbar sind. Da die Anzeige nur die Ziffern 0 bis 9 darstellen kann, wurden die 
verbleibenden Werte gemäß Aufgabenstellung~\cite{tamselKombinatorischeLogikProjekt2025} als „don’t care“ definiert.
\begin{figure}[H]
    \centering
    \includegraphics[width=0.9\textwidth]{bcd_to_7segment/numbers_on_a_7-segement-display.png}
    \caption{Darstellung der Ziffern 0 bis 9 auf der 7-Segment-Anzeige~\cite[Abb.~2]{tamselKombinatorischeLogikProjekt2025}}
    \label{fig:numbers_on_a_7-segment-display}
\end{figure}

\paragraph{KV-Diagramm}
In der Aufgabenstellung sind spezifische Normalformen verlangt. Diese sind entweder konjunktiv oder disjunktiv, welche genau ist aus der Aufgabenstellung zu entnehmen.~\cite[pp.~4-5]{tamselKombinatorischeLogikProjekt2025}

\paragraph{Beschränkter Gattervorrat}
Die aus den \gls{kv}-Diagrammen abgeleiteten Normalformen (siehe Tabelle~\ref{tab:kv_bcd_to_7segment}) wurden gemäß den Vorgaben der Aufgabenstellung~\cite[pp.~4–5]{tamselKombinatorischeLogikProjekt2025} angepasst.
Für die Realisierung der Schaltungen stand nur ein begrenzter Satz an Grundgattern zur Verfügung. So durfte beispielsweise das Segment A ausschließlich mit den Gattern \textsc{Xor} und \textsc{Or} umgesetzt werden~\cite[p.~4]{tamselKombinatorischeLogikProjekt2025}.
Die Umformungen der Normalformen erfolgten mithilfe der Booleschen Algebra und der De-Morgan-Theoreme.

\subsubsection{Ripple-Carry-Addierer}
Um den Ripple-Carry-Addierer zu realisieren, muss zuerst der Volladdierer gebaut werden. Anschliessend wird die erstellte Baugruppe für das Realisieren der Ripple-Carry-Addierer Baugruppe verwendet.
Der Volladdierer wird nicht einzeln in einem Testprotokoll getestet, da er im kombinierten Test der übergeordneten Baugruppe automatisch getestet wird.

\paragraph{Volladdierer}
Der Ripple-Carry-Addierer besteht aus mehreren, hintereinandergeschalteten Volladdierern. Ein Volladdierer verrechnet dabei jeweils drei Bits miteinander. Je ein Bit
der jeweiligen Summanden, sowie ein Übertragsbit des vorherigen Volladdierers. Das Ganze funktioniert also gleich, wie auch die schriftliche Addition. Der Volladdierer liefert dabei die Summe,
welche als Ergebnis an die jeweilige Stelle kommt, sowie ein Übertragsbit, welches an den Volladdierer der nächsten Stelle übergeben wird.

\paragraph{Ripple-Carry-Addierer}
Der Ripple-Carry-Addierer wird für die Addition zweier Binärzahlen verwendet. Er besteht aus mehreren Volladdierern, und kann
für eine unbegrenzte Anzahl Bits verwendet werden. Der Name \glqq Ripple\grqq~kommt daher, da bei der Berechnung jeweils ein Übertragsbit von einem Volladdierer zum nächsten durchgereicht wird.
Dadurch steigt aber auch die Latenz mit zunehmender Anzahl Bits, da jeder Volladdierer auf den Übertrag des letzten warten muss, bevor die Berechnung durchgeführt werden kann.~\cite{manoDigitalDesignIntroduction}

\paragraph{8-Bit-Addierer}
Aus dem entwickelten Volladdierer lassen sich nun beliebig grosse Addierer realisieren. Gemäss Aufgabenstellung~\cite{tamselKombinatorischeLogikProjekt2025} soll
ein 8-Bit-Addierer gebaut werden. Dies funktioniert durch Aneinanderreihung der Volladdierer und jeweiliger Übergabe des Übertrags auf den darauffolgenden
Volladdierer. Der Übertragsausgang des letzten Volladdierers wurde an den Ausgang \glqq Overflow\grqq~angeschlossen. Falls also die Summe der Addition zu gross ist, um
noch korrekt dargestellt werden zu können, wird dies rückgemeldet.

\subsubsection{Borrow-Bit-Subtrahierer}
Um den Borrow-Bit-Subtrahierer zu realisieren, muss zuerst der Vollsubtrahierer gebaut werden. Anschliessend wird die erstellte Baugruppe für das Realisieren der Borrow-Bit-Subtrahierer Baugruppe verwendet.
Der Vollsubtrahierer wird nicht einzeln in einem Testprotokoll getestet, da er im kombinierten Test der übergeordneten Baugruppe automatisch getestet wird.

\paragraph{Vollsubtrahierer}
Der Borrow-Bit-Subtrahierer besteht aus mehreren hintereinandergeschalteten Vollsubtrahierern. Jeder Vollsubtrahierer verarbeitet ein Bit des Minuenden, ein Bit des Subtrahenden,
sowie das Borrow-Bit (Übertragsbit) des vorherigen Vollsubtrahierers. Der Vollasubtrahierer liefert dabei das Differenzbit, welches als Ergebnis an die jeweilige Stelle kommt,
sowie ein Borrow-Bit, welches an den Vollsubtrahierer der nächsten Stelle übergeben wird, falls von dieser ein Bit geborgt werden muss. Die Funktionsweise entspricht damit der schriftlichen
Subtraktion, bei der, bei Bedarf, von der nächsthöheren Stelle \glqq ausgeliehen\grqq~wird.

\paragraph{8-Bit-Subtrahierer}
Aus dem entwickelten Vollsubtrahierer lassen sich nun beliebig grosse Subtrahierer realisieren. Gemäss Aufgabenstellung~\cite{tamselKombinatorischeLogikProjekt2025} soll
ein 8-Bit-Subtrahierer gebaut werden. Dies funktioniert durch Aneinanderreihung der Vollsubtrahierer und jeweiliger Übergabe des Übertrags auf den darauffolgenden
Vollsubtrahierer. Der Übertragsausgang des letzten Vollsubtrahierers wurde an den Ausgang \glqq Underflow\grqq~angeschlossen. Falls also die Differenz der Subtraktion kleiner als 0 ist,
wird dies rückgemeldet, so dass klar ist, dass das angezeigt Ergebnis nicht die korrekte Lösung der Rechnung ist.

\subsubsection{Ergebnisumschalter}
Mit dem gleichen Prinzip wie auch bei den vorherigen Schaltungen, ist der 8-Bit-Multiplexer aus mehreren 1-Bit-Multiplexern aufgebaut.
Daher muss zuerst der 1-Bit-Multiplexer realisiert werden. Dieser wird nicht einzeln in einem Testprotokoll getestet, da er im kombinierten Test der übergeordneten Baugruppe automatisch getestet wird.

\subsubsection{Binär-zu-BCD Umwandler}
Eine 7-Segment-Anzeige kann maximal 10 Ziffern anzeigen. Bei einer 8-Bit-Binärzahl kann somit nur ein Bruchteil ihres Wertes wiedergegeben werden. Damit eine 8-Bit-Binärzahl
in ihrer gesamtheitlichen Grösse wiedergegeben werden kann, sind 3 Ziffern nötig. Aus der 8-Bit-Binärzahl muss also für jede Ziffer der entsprechende \gls{bcd}-Wert ermittelt werden.
Wie genau dies gemacht wird kann aus der Vorbereitungsaufgabe entnommen werden. (Siehe Anhang~\ref{app:pdf}) Durch geeignetes Verknüpfen der erstellten Add3-Blöcke lässt sich die gewünschte Funktion erstellen.

\paragraph{Add3}
Sobald eine Zahl >=5 ist, wird der Wert 3 (0011 in binär) zu dieser Zahl dazugerechnet.